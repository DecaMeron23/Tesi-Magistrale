/*
 * TLC59731.c
 *
 *  Created on: 10 gen 2026
 *      Author: emilio
 */

#include "TLC59731.h"

extern TIM_HandleTypeDef TLC59731_TIM;

#define TLC59731_MSB_MASK 		0x000080
#define TLC59731_WRITE_COMMAND 	0x0000003A
#define TLC59731_T_CYCLE 		25u
#define TLC59731_PULSE_CYCLE 	5u

void writeByte(uint8_t byte);
void writeBit_0();
void writeBit_1();
void pulsePin();
void delayMicro(uint32_t delay);
void startTimer();
void stopTimer();
void writeEOS();
void writeCommand();
void writeGSLAT();

uint8_t writeData(uint8_t *RGB);

enum TLC59731_STATE
{
	TLC59731_STATE_ON, TLC59731_STATE_OFF
};

enum TLC59731_COLOUR
{
	TLC59731_RED, TLC59731_GREEN, TLC59731_BLUE, TLC59731_NUM_COLOUR,
};

struct TLC59731_TypeDef
{
	uint8_t RGB_value[TLC59731_NUM_COLOUR];
	enum TLC59731_STATE state;
};

struct TLC59731_TypeDef led;

uint8_t TLC59731_Init()
{
	led.state = TLC59731_STATE_OFF;
	TLC59731_SetRGB(0x00, 0x00, 0x00);
	TLC59731_Off();
	return 0;
}

uint8_t TLC59731_SendRGB(uint8_t red, uint8_t green, uint8_t blue)
{
	TLC59731_SetRGB(red, green, blue);
	TLC59731_On();
	return 0;
}

uint8_t TLC59731_SetRGB(uint8_t red, uint8_t green, uint8_t blue)
{
	led.RGB_value[TLC59731_RED] = red;
	led.RGB_value[TLC59731_GREEN] = green;
	led.RGB_value[TLC59731_BLUE] = blue;
	return 0;
}

uint8_t TLC59731_On()
{
	led.state = TLC59731_STATE_ON;
	return writeData(led.RGB_value);
}

uint8_t TLC59731_Off()
{
	uint8_t rgb[] =
	{ 0x00, 0x00, 0x00 };
	led.state = TLC59731_STATE_OFF;
	return writeData(rgb);
}

uint8_t TLC59731_Toggle()
{
	if (led.state == TLC59731_STATE_ON)
	{
		TLC59731_Off();
	}
	else
	{
		TLC59731_On();
	}
	return 0;
}

/**
 * RGB array lungo TLC59731_NUM_COLOR
 */
uint8_t writeData(uint8_t *RGB)
{
	HAL_GPIO_WritePin(TLC59731_CS_PORT, TLC59731_CS_PIN, GPIO_PIN_SET);

	startTimer();

	writeCommand();

	// Scrittura dei colori
	for (uint8_t i = 0; i < TLC59731_NUM_COLOUR; i++)
	{
		writeByte(RGB[i]);
	}

//	writeEOS();
//	writeGSLAT();

	stopTimer();

	HAL_GPIO_WritePin(TLC59731_CS_PORT, TLC59731_CS_PIN, GPIO_PIN_RESET);

	return 0;
}

/**
 * Il primo bite scritto deve essere il MSB
 */
void writeByte(uint8_t byte)
{
	uint8_t data = byte;
	for (uint8_t i = 0; i < 8; i++)
	{
		uint8_t val = data & TLC59731_MSB_MASK;
		if (val == 0)
		{
			writeBit_0();
		}
		else
		{
			writeBit_1();
		}
		data = data << 1;
	}
}

void writeCommand()
{
	writeByte(TLC59731_WRITE_COMMAND);
}

void writeGSLAT()
{
	pulsePin();
	delayMicro(TLC59731_T_CYCLE * 10);
	pulsePin();
}

void writeEOS()
{
	pulsePin();
	delayMicro(TLC59731_T_CYCLE * 4);
	pulsePin();
}

void writeBit_0()
{
	pulsePin();
	delayMicro(TLC59731_T_CYCLE);
}
void writeBit_1()
{
	pulsePin();
	delayMicro(TLC59731_T_CYCLE / 2);
	pulsePin();
	delayMicro(TLC59731_T_CYCLE / 2);
}

void pulsePin()
{
	HAL_GPIO_WritePin(TLC59731_PWM_PORT, TLC59731_PWM_PIN, GPIO_PIN_SET);
	delayMicro(TLC59731_PULSE_CYCLE);
	HAL_GPIO_WritePin(TLC59731_PWM_PORT, TLC59731_PWM_PIN, GPIO_PIN_RESET);
}

void startTimer()
{

	HAL_TIM_Base_Start(&TLC59731_TIM);
}

void stopTimer()
{
	HAL_TIM_Base_Stop(led.tim);
}

/**
 * Ipotesi Il timer va a 32MHz
 */
void delayMicro(uint32_t delay)
{
	delay *= 32;
	uint16_t start = __HAL_TIM_GET_COUNTER(led.tim);
	while (__HAL_TIM_GET_COUNTER(led.tim) - start < delay)
	{
	}
}
