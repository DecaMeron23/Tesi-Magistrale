/*
 * srv_pwm.c
 *
 *  Created on: 14 gen 2026
 *      Author: emilio
 */

//INCLUDE HEADER
#include "Services/PWM/srv_pwm.h"

//INCLUDE SMT
#include "custom_stm.h"
#include "stm32_seq.h"
#include "stdlib.h"

//INCLUDE
#include "PWM_SIGNAL/pwm_signal.h"

//DEFINE
#define PWM_SIGNAL_CINQUE_SECONDI (5 * 1e6 / CFG_TS_TICK_VAL)
#define PWM_SIGNAL_DUE_SECONDI (2 * 1e6 / CFG_TS_TICK_VAL)

#define PWM_SIGNAL_FREQ_CLK		32000000U
#define PWM_SIGNAL_PRE_SCALER	3200
#define PWM_SIGNAL_IS_16_BIT	0

typedef struct
{
	uint8_t *pDataNotify;
	uint8_t timerFreq_ID;
	uint8_t timerDuty_ID;
	PWM_SIGNAL_TypeDef sPWMSignal;

} SRV_Contest_TypeDef;

static SRV_Contest_TypeDef contestSrv;

void callBackNotifyFreq_ISR(void)
{
	UTIL_SEQ_SetTask(1 << CFG_TASK_SRV_PWM_NOTIFY_ID, CFG_SCH_PRIO_0);
}

void callBackNotifyDuty_ISR(void)
{
	UTIL_SEQ_SetTask(1 << CFG_TASK_SRV_DUTY_NOTIFY_ID, CFG_SCH_PRIO_0);
}

void callBackNotifyFreq(void)
{
	SRV_PWM_ReadFrequency(contestSrv.pDataNotify);
}

void callBackNotifyDuty(void)
{
	SRV_PWM_ReadDutyCycle(contestSrv.pDataNotify);
}

void StartStopNotify(uint8_t state, uint8_t timerID, uint32_t period)
{
	if (state)
	{
		HW_TS_Start(timerID, period);
	}
	else
	{
		HW_TS_Stop(timerID);
	}
}

uint32_t getFrequency()
{
	static const uint32_t max_freq = 1500;
	static const uint32_t min_freq = 500;
	return min_freq + rand() % (max_freq - min_freq + 1);
}

uint8_t getDutyCycle()
{
	static const uint8_t max_duty = 100;
	static const uint8_t min_duty = 0;
	return min_duty + rand() % (max_duty - min_duty + 1);
}

void SRV_PWM_Init(uint8_t IDTimerFrequency, uint8_t IDTimerDutyCycle, uint8_t *pDataNotify)
{
	// Inizzializzazione del contesto
	contestSrv.timerFreq_ID = IDTimerFrequency;
	contestSrv.timerDuty_ID = IDTimerDutyCycle;
	contestSrv.pDataNotify = pDataNotify;

	PWM_SIGNAL_Init(&contestSrv.sPWMSignal, PWM_SIGNAL_FREQ_CLK, PWM_SIGNAL_PRE_SCALER, PWM_SIGNAL_IS_16_BIT);

	// Creazione dei task di callback
	UTIL_SEQ_RegTask(1 << CFG_TASK_SRV_PWM_NOTIFY_ID, UTIL_SEQ_RFU, callBackNotifyFreq);
	UTIL_SEQ_RegTask(1 << CFG_TASK_SRV_DUTY_NOTIFY_ID, UTIL_SEQ_RFU, callBackNotifyDuty);

	// Creazione dei timer per le notify
	if (HW_TS_Create(CFG_TIM_PROC_ID_ISR, &(contestSrv.timerFreq_ID), hw_ts_Repeated, callBackNotifyFreq_ISR)
			!= hw_ts_Successful)
	{
		Error_Handler();
	}
	if (HW_TS_Create(CFG_TIM_PROC_ID_ISR, &(contestSrv.timerDuty_ID), hw_ts_Repeated, callBackNotifyDuty_ISR)
			!= hw_ts_Successful)
	{
		Error_Handler();
	}

}

void SRV_PWM_ReadFrequency(uint8_t *pData)
{
	HAL_Delay(10);
	uint32_t freq = PWM_SIGNAL_GetFrequency(&contestSrv.sPWMSignal);

	uint32_t mask = 0xff000000;
	for (int i = 0; i < 4; i++)
	{
		pData[i] = freq & mask;
		mask >>= 8;
	}
	Custom_STM_App_Update_Char(CUSTOM_STM_PWM_FREQ_CHAR, pData);
}

void SRV_PWM_NotifyFrequency(uint8_t state)
{
	StartStopNotify(state, contestSrv.timerFreq_ID, PWM_SIGNAL_DUE_SECONDI);
}

void SRV_PWM_ReadDutyCycle(uint8_t *pData)
{
	pData[0] = PWM_SIGNAL_GetDutyCycle(&contestSrv.sPWMSignal);
	Custom_STM_App_Update_Char(CUSTOM_STM_PWM_DUTY_CHAR, pData);
}

void SRV_PWM_NotifyDutyCycle(uint8_t state)
{
	StartStopNotify(state, contestSrv.timerDuty_ID, PWM_SIGNAL_CINQUE_SECONDI);
}

void SRV_PWM_HandlerPWMSignal(TIM_HandleTypeDef *htim)
{
	switch (htim->Channel)
	{
		case HAL_TIM_ACTIVE_CHANNEL_1:
			PWM_SIGNAL_ComputePWM(&contestSrv.sPWMSignal, htim, TIM_CHANNEL_1, 1);
			break;
		case HAL_TIM_ACTIVE_CHANNEL_2:
			PWM_SIGNAL_ComputePWM(&contestSrv.sPWMSignal, htim, TIM_CHANNEL_2, 0);
		default:
			break;
	}
}

