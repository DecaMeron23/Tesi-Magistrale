/*
 * MX25L4006E.c
 *
 *  Created on: 16 gen 2026
 *      Author: emilio
 */

#include "MX25L4x.h"

extern SPI_HandleTypeDef MX25L4_SPI;

// Define dei comandi
#define MX25L4_CMD_WREN 0x06		/**< Write Enable: comando di abilitazione alla scrittura*/
#define MX25L4_CMD_WRDI 0x04		/**< Write Disable: comando di disabilitazione alla scrittura*/
#define MX25L4_CMD_RDID 0x9F		/**< Read Id: comando di lettura dell'ID del produttore più 2-Byte di ID della memoria*/
#define MX25L4_CMD_RDSR 0x05		/**< Read Status Register: comando di lettura dei registri della memoria */
#define MX25L4_CMD_READ 0x03		/**< Read: Comando di lettura, sono necessari 3 parametri e che il CS sia LOW */
#define MX25L4_CMD_SE	0x20		/**< Selector Erease: pone a HIGH tutti i bit del settore, necessita di 3 parametri */
#define MX25L4_CMD_BE 	0x52		/**< Block Erease: pone a HIGH tutti i bit del blocco, necessita di 3 parametri */
#define MX25L4_CMD_CE 	0x60		/**< Chip Erease: pone a HIGH tutti i bit del chip */
#define MX25L4_CMD_DP 	0xB9		/**< Deep Power: il dispositivo va in modalità low power*/
#define MX25L4_CMD_RDP 	0xAB		/**< Release Deep Power: il dispositivo esce dalla modalità low power*/

#define MX25L4_MAX_RW_TIME 3000u  	/**< Tempo massimo per la lettura e scrittura*/
#define MX25L4_MAX_CMD_TIME 100u  	/**< Tempo massimo per l'invio dei comandi*/

#define MX25L4_FORWARD_CHECK 8		/**< Numero di byte da controllare per determinare che quel bocco è libero */
/**< Non può essere inferiore all'header della memoria, ovvero 4 Byte */

#if  MX25L4_FORWARD_CHECK  < 4 // Controllo che nonscenda sotto 4 byte
#undef MX25L4_FORWARD_CHECK
#define MX25L4_FORWARD_CHECK 4
#endif

// Definizione delle macro
#define MX25L4_BYTE0(VAL)	((VAL) & 0xFF)
#define MX25L4_BYTE1(VAL)	((VAL >> 8) & 0xFF)
#define MX25L4_BYTE2(VAL)	((VAL >> 16) & 0xFF)
#define MX25L4_BYTE3(VAL)	((VAL >> 24) & 0xFF)

//***********************************************************
//++++++++++++ Definizione Variabili Private ++++++++++++++++
//***********************************************************

typedef struct
{
	uint8_t packetSize; /**< Dimensione del pacchetto */
	uint16_t firmwareVersion; /**< Versione del firmware */
	uint32_t addrFreeSpace; /**< Ultimo indirizzo scritto */
} MX25L4_TypeDef;

MX25L4_TypeDef memoryContext;

//***********************************************************
//++++++++++++ Definizione delle Funzioni +++++++++++++++++++
//***********************************************************

/**
 * Attivazione del Chip Select
 */
void CS_Select();

/**
 * Deselezione del Chip Select
 */
void CS_Unselect();

/**
 * Trasmissione con SPI
 */
bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Ricezione con SPI
 */
bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Invio di un comando singolo con SPI, attiva e disattiva in automatico il chip select
 */
bool SPI_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Algoritmo per l'inizializzazione del contesto
 */
bool MEM_InitContext();

/**
 * Ricerca del primo blocco libero, modifica il contesto
 * @param start_address		Indirizzo di partenza per effettuare la ricerca
 *
 * @return	False se all'indirizzo start_address non è stato trovato l'header
 */
bool MEM_findFreeSpace(uint32_t start_address);

/**
 * Verifica se è un Header valido della memoria
 *
 * @param pData		puntatore all'array di 4 Byte
 */
bool MEM_IsHeader(uint8_t *pData);
//***********************************************************
//++++++++++++++++ Funzioni Public ++++++++++++++++++++++++++
//***********************************************************
bool MX25L4_Init(void)
{
	bool isOK = true;

// Inizzializzazione del contesto
	memoryContext.packetSize = 0;
	memoryContext.firmwareVersion = 0;
	memoryContext.addrFreeSpace = 0;

// Inizializzazione - CS e HOLD
	CS_Unselect();
	HAL_GPIO_WritePin(MX25L4_HOLD_Port, MX25L4_HOLD_Pin, GPIO_PIN_SET);

// Inizializzazione - SPI [GIÀ FATTO NEL MAIN.. DEVO FARLO?]
//	isOK &= HAL_SPI_Init(&MX25L4_hspi) == HAL_OK;

// Verifica del funzionamento del dispositivo
	uint8_t memID[3];
	isOK &= MX25L4_ReadID((uint8_t*) memID);

	isOK &= (memID[0] == MX25L4_BYTE2(MX25L4_ID));
	isOK &= (memID[1] == MX25L4_BYTE1(MX25L4_ID));
	isOK &= (memID[2] == MX25L4_BYTE0(MX25L4_ID));

	MEM_InitContext();

	return isOK;
}

bool MX25L4_ReadID(uint8_t *aID)
{
	uint8_t cmd = MX25L4_CMD_RDID;
	bool isOK = true;

// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(aID, 3, MX25L4_MAX_CMD_TIME);

// Chip Select - OFF
	CS_Unselect();

	return isOK;
}

bool MX25L4_ReadData(uint8_t *pData, uint16_t size, uint32_t address)
{
	uint8_t isOK = true;
	uint8_t cmd[4] =
	{ MX25L4_CMD_READ, MX25L4_BYTE2(address), MX25L4_BYTE1(address), MX25L4_BYTE0(address) };

// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(cmd, 4, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pData, size, MX25L4_MAX_RW_TIME);

// Chip Select - OFF
	CS_Unselect();

	return isOK;
}

bool MX25L4_Sleep()
{
	uint8_t cmd = MX25L4_CMD_DP;

	return SPI_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_Wakeup()
{
	uint8_t cmd = MX25L4_CMD_RDP;

	return SPI_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_isOccupied()
{
	uint8_t registerStatus;
	uint8_t cmd = MX25L4_CMD_RDSR;

// Chip Select - ON
	CS_Select();

	SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	SPI_Receive(&registerStatus, 1, MX25L4_MAX_RW_TIME);

// Chip Select - OFF
	CS_Unselect();

	return (registerStatus & 0x01) == 0x01; // Lettura dell'ultimo bit e verifica se è pari a 1 (Occupato)
}

bool MX25L4_WriteData(uint8_t *pData, uint16_t size, uint32_t *address)
{

//TODO basta

	uint8_t isOK = true;
	uint8_t cmdWREN = MX25L4_CMD_WREN;

	CS_Select();

	isOK &= SPI_Transmit(&cmdWREN, 1, MX25L4_MAX_CMD_TIME);

	CS_Unselect();

	return false;
}

//***********************************************************
//++++++++++++++++ Funzioni Private ++++++++++++++++++++++++++
//***********************************************************

inline void CS_Select()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_RESET);
}

inline void CS_Unselect()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_SET);
}

inline bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Transmit(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

inline bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Receive(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

bool SPI_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	bool isOK = true;

// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(pData, Size, Timeout);

// Chip Select - OFF
	CS_Unselect();

	return isOK;

}

// TODO
bool MEM_InitContext()
{
	bool isOK = true;

// Lettura delle informazioni iniziali
	uint32_t add = 0x00;
	uint8_t pData[4] =
	{ 0, 0, 0, 0 };
	MX25L4_ReadData(pData, 4, add);

	if (pData[0] != 0xFF) // se vero -> qual cosa è andato storto
	{
		return false;
	}

	if (pData[1] == 0xFF && pData[2] == 0xFF && pData[3] == 0xFF) // se vero -> memoria non inizializzata
	{
		// Scrivi versione del firmware e dimensioni del pacchetto (DA DOVE LE PRENDO?)
		// TODO

		memoryContext.addrFreeSpace = add + 4;
//		memoryContext.packetSize  = ??
//		memoryContext.firmwareVersion = ??
		return true;
	}

	memoryContext.packetSize = pData[3];
	memoryContext.firmwareVersion = (pData[1] << 8) | pData[2];

	MEM_findFreeSpace();

	return isOK;
}

bool MEM_findFreeSpace(uint32_t start_address)
{
	bool stop = false;
	uint8_t pData[MX25L4_FORWARD_CHECK];
	MX25L4_ReadData(pData, MX25L4_FORWARD_CHECK, start_address);
	if (!MEM_IsHeader(pData))
	{
		return false;
	}

	uint32_t i = 0;
	do
	{

		if (MEM_IsHeader(pData))
		{
			memoryContext.firmwareVersion = pData[1] << 8 | pData[2];
			memoryContext.packetSize = pData[3];
		}
		// TODO continua qua
		i++;

	} while (!stop);
	return false;
}

// TODO
bool MEM_IsHeader(uint8_t *pData)
{
	return false;
}

