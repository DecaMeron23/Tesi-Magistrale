/*
 * MX25L4006E.c
 *
 *  Created on: 16 gen 2026
 *      Author: emilio
 */

#include "MX25L4x.h"
#include "stdlib.h"
#include "string.h"

extern SPI_HandleTypeDef MX25L4_SPI;

// Informazioni sulla memoria
#define MX25L4_MEM_BLOCK 	8			/**< Numero di blocchi di memoria */
#define MX25L4_MEM_SECTOR 	16			/**< Numero di settori per blocco */
#define MX25L4_MEM_PAGE 	256			/**< Byte per settore (page)*/

// Define dei comandi
#define MX25L4_CMD_WREN 0x06		/**< Write Enable: comando di abilitazione alla scrittura*/
#define MX25L4_CMD_WRDI 0x04		/**< Write Disable: comando di disabilitazione alla scrittura*/
#define MX25L4_CMD_RDID 0x9F		/**< Read Id: comando di lettura dell'ID del produttore più 2-Byte di ID della memoria*/
#define MX25L4_CMD_RDSR 0x05		/**< Read Status Register: comando di lettura dei registri della memoria */
#define MX25L4_CMD_READ 0x03		/**< Read: Comando di lettura, sono necessari 3 parametri e che il CS sia LOW */
#define MX25L4_CMD_SE	0x20		/**< Selector Erease: pone a HIGH tutti i bit del settore, necessita di 3 parametri */
#define MX25L4_CMD_BE 	0x52		/**< Block Erease: pone a HIGH tutti i bit del blocco, necessita di 3 parametri */
#define MX25L4_CMD_CE 	0x60		/**< Chip Erease: pone a HIGH tutti i bit del chip */
#define MX25L4_CMD_DP 	0xB9		/**< Deep Power: il dispositivo va in modalità low power*/
#define MX25L4_CMD_RDP 	0xAB		/**< Release Deep Power: il dispositivo esce dalla modalità low power*/
#define MX25L4_CMD_PP	0x02		/**< Page Program: scrittura della memoria */

// Definizione dei timeout
#define MX25L4_MAX_RW_TIME 3000u  	/**< Tempo massimo per la lettura e scrittura*/
#define MX25L4_MAX_CMD_TIME 100u  	/**< Tempo massimo per l'invio dei comandi*/

// Definizione dell'header
#define MX25L4_HEADER_BYTE_0 0xFF	/**< Valore del primo Byte dell'header. TODO proposta di header */
#define MX25L4_HEADER_BYTE_1 0x55 	/**< Valore del secondo Byte dell'header. TODO proposta di header */
#define MX25L4_HEADER_BYTE_NUM	4	/**< Dimensione in byte dell'header*/

// Ricerca memoria
#define MX25L4_FORWARD_CHECK 	8	/**< Numero di byte da controllare per determinare che quel bocco è libero
non può essere inferiore all'header della memoria, ovvero "MX25L4_HEADER_BYTE_NUM" */

#if  MX25L4_FORWARD_CHECK  < MX25L4_HEADER_BYTE_NUM // Controllo che nonscenda sotto 4 byte
#undef MX25L4_FORWARD_CHECK
#define MX25L4_FORWARD_CHECK MX25L4_HEADER_BYTE_NUM
#endif

// Definizione delle macro
#define MX25L4_BYTE0(VAL)	((VAL) & 0xFF)
#define MX25L4_BYTE1(VAL)	((VAL >> 8) & 0xFF)
#define MX25L4_BYTE2(VAL)	((VAL >> 16) & 0xFF)
#define MX25L4_BYTE3(VAL)	((VAL >> 24) & 0xFF)

#define MX25L4_MIN(V1 , V2)	(V1 > V2 ? V2 : V1)

#define MX25L4_DEBUG
//***********************************************************
//++++++++++++ Definizione Variabili Private ++++++++++++++++
//***********************************************************

typedef struct
{
	uint8_t packetSize; /**< Dimensione del pacchetto */
	uint16_t firmwareVersion; /**< Versione del firmware */
	uint32_t addrFreeSpace; /**< Ultimo indirizzo scritto */
} MX25L4_TypeDef;

MX25L4_TypeDef memoryContext;

//***********************************************************
//++++++++++++ Definizione delle Funzioni +++++++++++++++++++
//***********************************************************

/**
 * Attivazione del Chip Select
 */
void CS_Select();

/**
 * Deselezione del Chip Select
 */
void CS_Unselect();

/**
 * Trasmissione con SPI
 */
bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Ricezione con SPI
 */
bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Invio di un comando singolo con SPI, attiva e disattiva in automatico il chip select
 */
bool SPI_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Inizzializza il contesto
 *
 * @param pData		Array con i 4 Byte dell'header
 */
bool MEM_UpdateContext(uint8_t *pData);

/**
 * Ricerca del primo blocco libero, modifica il contesto
 * @param start_address		Indirizzo di partenza per effettuare la ricerca
 *
 * @return	False se all'indirizzo start_address non è stato trovato l'header, altrimenti true.
 */
bool MEM_FindFreeSpace(uint32_t start_address);

/**
 * Verifica se è un Header valido della memoria
 *
 * @param pData		puntatore all'array di lunghezza "MX25L4_HEADER_BYTE_NUM"
 */
bool MEM_IsHeader(uint8_t *pData);

/**
 * Scrittura dell'header sulla memoria
 *
 * @param addr		Indirizzo dove scrivere l'header
 */
bool MEM_WriteHeader(uint32_t addr);

/**
 * Scrittura sulla memoria all'indirizzo specificato
 *
 * @param pData 	Dati da scrivere in memoria
 * @param size 		numero di byte da scrivere
 * @param addr		indirizzo su cui scrivere la memoria
 *
 */
bool MEM_Write(uint8_t *pData, uint16_t size, uint32_t addr);

/**
 * Veridica se l'area di memoria è tutta libera
 *
 * @param pData		L'array da verificare
 * @param size		dimensione dell'array
 *
 * @return			True, se tutti i valori di pData sono a 0xFF altrimenti false.
 */
bool MEM_IsFree(uint8_t *pData, uint8_t size);

/**
 * Lettura dei registri della memoria
 *
 *  @param registerStatus	[out] valori dei registri lettiFss
 */
bool MEM_ReadRegister(uint8_t *pData);

//***********************************************************
//++++++++++++++++ Funzioni Public ++++++++++++++++++++++++++
//***********************************************************

bool MX25L4_Init(void)
{
	bool isOK = true;

	// Inizzializzazione del contesto
	memoryContext.packetSize = 0;
	memoryContext.firmwareVersion = 0;
	memoryContext.addrFreeSpace = 0;

	// Inizializzazione - CS e HOLD
	CS_Unselect();
	HAL_GPIO_WritePin(MX25L4_HOLD_Port, MX25L4_HOLD_Pin, GPIO_PIN_SET);

	// Inizializzazione - SPI [GIÀ FATTO NEL MAIN.. DEVO FARLO?]
	//isOK &= HAL_SPI_Init(&MX25L4_hspi) == HAL_OK;

	// Verifica del funzionamento del dispositivo
	uint8_t memID[3];
	isOK &= MX25L4_ReadID((uint8_t*) memID);

	isOK &= (memID[0] == MX25L4_BYTE2(MX25L4_ID));
	isOK &= (memID[1] == MX25L4_BYTE1(MX25L4_ID));
	isOK &= (memID[2] == MX25L4_BYTE0(MX25L4_ID));

	// inizializzazione del contesto della memoria
	if (!MEM_FindFreeSpace(0x00)) // se vero -> header non trovato!
	{
		MEM_WriteHeader(0x00); // scrittura dell'header
	}

	return isOK;
}

bool MX25L4_ReadID(uint8_t *aID)
{
	uint8_t cmd = MX25L4_CMD_RDID;
	bool isOK = true;

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(aID, 3, MX25L4_MAX_CMD_TIME);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;
}

bool MX25L4_ReadData(uint8_t *pData, uint16_t size, uint32_t address)
{
	uint8_t isOK = true;
	uint8_t cmd[4] =
	{ MX25L4_CMD_READ, MX25L4_BYTE2(address), MX25L4_BYTE1(address), MX25L4_BYTE0(address) };

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(cmd, 4, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pData, size, MX25L4_MAX_RW_TIME);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;
}

bool MX25L4_Sleep()
{
	uint8_t cmd = MX25L4_CMD_DP;

	return SPI_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_Wakeup()
{
	uint8_t cmd = MX25L4_CMD_RDP;

	return SPI_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_isOccupied()
{
	uint8_t registerStatus;
	MEM_ReadRegister(&registerStatus);
	return (registerStatus & 0x01) == 0x01; // Lettura dell'ultimo bit e verifica se è pari a 1 (Occupato)
}

bool MX25L4_WriteData(uint8_t *pData, uint16_t size, uint32_t *address)
{
	if (address != NULL)
	{
		*address = memoryContext.addrFreeSpace;
	}
	return MEM_Write(pData, size, memoryContext.addrFreeSpace);
}

//***********************************************************
//++++++++++++++++ Funzioni Private ++++++++++++++++++++++++++
//***********************************************************

inline void CS_Select()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_RESET);
}

inline void CS_Unselect()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_SET);
}

inline bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Transmit(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

inline bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Receive(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

bool SPI_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	bool isOK = true;

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(pData, Size, Timeout);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;

}

bool MEM_UpdateContext(uint8_t *pData)
{
	memoryContext.firmwareVersion = pData[1] << 8 | pData[2];
	memoryContext.packetSize = pData[3];
	return true;
}

bool MEM_FindFreeSpace(uint32_t start_address)
{
	bool stop = false;
	uint8_t pData[MX25L4_FORWARD_CHECK];

	MX25L4_ReadData(pData, MX25L4_FORWARD_CHECK, start_address);
	if (!MEM_IsHeader(pData))
	{
		return false;
	}

	MEM_UpdateContext(pData); // Aggiorniamo il contesto della memoria

	uint32_t addr = start_address + MX25L4_HEADER_BYTE_NUM; // partiamo a leggere dal primo blocco libero

	// Ciclo di scan della memoria
	while (!stop)
	{
		MX25L4_ReadData(pData, MX25L4_FORWARD_CHECK, addr);

		if (MEM_IsHeader(pData)) // Se vero -> Aggiorniamo il contesto della memoria
		{
			MEM_UpdateContext(pData);
		}
		else if (MEM_IsFree(pData, MX25L4_FORWARD_CHECK)) // se vero -> ci fermiamo e aggiorniamo il contesto
		{
			if (memoryContext.firmwareVersion != MX25L4_FIRMWARE_VERSION) // se vero -> scriviamo l'header della nuova versione
			{
				MEM_WriteHeader(addr);
				addr += MX25L4_HEADER_BYTE_NUM;
			}
			memoryContext.addrFreeSpace = addr;
			stop = true;
		}

		addr += memoryContext.packetSize; // Continuiamo ad avanzare
	}

	return true;
}

bool MEM_WriteHeader(uint32_t addr)
{
	uint8_t pData[MX25L4_HEADER_BYTE_NUM] =
	{ MX25L4_HEADER_BYTE_0, MX25L4_HEADER_BYTE_1, MX25L4_FIRMWARE_VERSION, MX25L4_PACKET_SIZE };

	return MEM_Write(pData, MX25L4_HEADER_BYTE_NUM, addr);
}

bool MEM_IsHeader(uint8_t *pData)
{
	bool isOK = true;
	isOK &= pData[0] == MX25L4_HEADER_BYTE_0;
	isOK &= pData[1] == MX25L4_HEADER_BYTE_1;
	isOK &= (pData[2] == (memoryContext.firmwareVersion + 1)); 	// Versioni del firmware consecutive TODO da chiedere
	isOK &= ((pData[3] % 2) == 0); 								// Dimensioni del pacchetto "pari" TODO da chiedere
	return isOK;
}

bool MEM_IsFree(uint8_t *pData, uint8_t size)
{
	for (uint8_t i = 0; i < size; i++)
	{
		if ((pData[i] & 0xFF) != 0xFF)
		{
			return false;
		}
	}
	return true;
}

bool MEM_Write(uint8_t *pData, uint16_t size, uint32_t addr)
{
	bool isOK = true;

	uint8_t cmdWREN = MX25L4_CMD_WREN;
	uint8_t payLoad = 1 + 3; // payLoad per inviare il comando: CMD + ADD1 + ADD2 + ADD3
	// Creo un'area di memoria continua (comando + indirizzo + dati) in modo tale da
	uint8_t *cmdWRITE = malloc((size_t) (payLoad + MX25L4_MIN(size, MX25L4_MEM_PAGE))); // TODO da chiedere se va bene

	// verifica se si è riusciti ad allocare la memoria
	if (cmdWRITE == NULL)
	{
		return false;
	}

	uint16_t daScrivere = 0; 	// dati da scrivere attraverso uno comando
	bool stop = false; 			// Indica se si deve concludere il ciclo while

	cmdWRITE[0] = MX25L4_CMD_PP;

	while (!stop)
	{
		// se l'indirizzo finale è diverso da 0x00 scriviamo solo i dati che ci stanno nella pagina attuale
		if (MX25L4_BYTE0(addr) != 0x00)
		{
			daScrivere = MX25L4_MEM_PAGE - MX25L4_BYTE0(addr); // scrivo solo i dati che ci stanno
		}
		else if (size > MX25L4_MEM_PAGE) // Se il size è maggiore della dimensione della pagina scrivamo solo 256 byte
		{
			daScrivere = MX25L4_MEM_PAGE;
			size -= MX25L4_MEM_PAGE;
		}
		else
		{
			daScrivere = size;
			size = 0;
			stop = true;
		}

		// scrittura dei comandi
		cmdWRITE[1] = MX25L4_BYTE2(addr);
		cmdWRITE[2] = MX25L4_BYTE1(addr);
		cmdWRITE[3] = MX25L4_BYTE0(addr);

		memcpy(cmdWRITE + 4, pData, daScrivere);

		CS_Select();
		isOK &= SPI_Transmit(&cmdWREN, 1, MX25L4_MAX_CMD_TIME);

		// Scrittura dei dati
		isOK &= SPI_Transmit(cmdWRITE, daScrivere, MX25L4_MAX_RW_TIME);

#ifdef MX25L4_DEBUG
		uint8_t registerValue = 0;
		MEM_ReadRegister(&registerValue);
#endif

		CS_Unselect();

		addr += daScrivere;
		size -= daScrivere;
	}

	// Dichiaro che le celle di memoria prima sono state scritte
	memoryContext.addrFreeSpace += addr; // TODO

	return false;
}

bool MEM_ReadRegister(uint8_t *pData)
{
	bool isOK = true;
	uint8_t cmd = MX25L4_CMD_RDSR;
	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pData, 1, MX25L4_MAX_RW_TIME);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;
}
