/*
 * MX25L4006E.c
 *
 *  Created on: 16 gen 2026
 *      Author: emilio
 */

#include "MX25L4x.h"
#include "stdlib.h"
#include "string.h"

extern SPI_HandleTypeDef MX25L4_SPI;

// Informazioni sulla memoria
#define MX25L4_MEM_BLOCK 	8			/**< Numero di blocchi di memoria */
#define MX25L4_MEM_SECTOR 	16			/**< Numero di settori per blocco */
#define MX25L4_MEM_PAGE 	256			/**< Byte per settore (page)*/

// Define dei comandi
#define MX25L4_CMD_WREN 0x06		/**< Write Enable: comando di abilitazione alla scrittura*/
#define MX25L4_CMD_WRDI 0x04		/**< Write Disable: comando di disabilitazione alla scrittura*/
#define MX25L4_CMD_RDID 0x9F		/**< Read Id: comando di lettura dell'ID del produttore più 2-Byte di ID della memoria*/
#define MX25L4_CMD_RDSR 0x05		/**< Read Status Register: comando di lettura dei registri della memoria */
#define MX25L4_CMD_READ 0x03		/**< Read: Comando di lettura, sono necessari 3 parametri e che il CS sia LOW */
#define MX25L4_CMD_SE	0x20		/**< Selector Erease: pone a HIGH tutti i bit del settore, necessita di 3 parametri */
#define MX25L4_CMD_BE 	0x52		/**< Block Erease: pone a HIGH tutti i bit del blocco, necessita di 3 parametri */
#define MX25L4_CMD_CE 	0x60		/**< Chip Erease: pone a HIGH tutti i bit del chip */
#define MX25L4_CMD_DP 	0xB9		/**< Deep Power: il dispositivo va in modalità low power*/
#define MX25L4_CMD_RDP 	0xAB		/**< Release Deep Power: il dispositivo esce dalla modalità low power*/
#define MX25L4_CMD_PP	0x02		/**< Page Program: scrittura della memoria */

// Definizione dei timeout
#define MX25L4_MAX_RW_TIME 3000u  	/**< Tempo massimo per la lettura e scrittura*/
#define MX25L4_MAX_CMD_TIME 100u  	/**< Tempo massimo per l'invio dei comandi*/

// Definizione dell'header
#define MX25L4_HEADER_BYTE_0 0xFF	/**< Valore del primo Byte dell'header. TODO proposta di header */
#define MX25L4_HEADER_BYTE_1 0x55 	/**< Valore del secondo Byte dell'header. TODO proposta di header */
#define MX25L4_HEADER_BYTE_NUM	4	/**< Dimensione in byte dell'header*/

// Ricerca memoria
#define MX25L4_FORWARD_CHECK 	8	/**< Numero di byte da controllare per determinare che quel bocco è libero
non può essere inferiore all'header della memoria, ovvero "MX25L4_HEADER_BYTE_NUM" */

#if  MX25L4_FORWARD_CHECK  < MX25L4_HEADER_BYTE_NUM // Controllo che non diventi più piccolo dell'header
#undef MX25L4_FORWARD_CHECK
#define MX25L4_FORWARD_CHECK MX25L4_HEADER_BYTE_NUM
#endif

// Definizione delle macro
#define MX25L4_BYTE0(VAL)	((VAL) & 0xFF)
#define MX25L4_BYTE1(VAL)	((VAL >> 8) & 0xFF)
#define MX25L4_BYTE2(VAL)	((VAL >> 16) & 0xFF)
#define MX25L4_BYTE3(VAL)	((VAL >> 24) & 0xFF)

#define MX25L4_MIN(V1 , V2)	(V1 > V2 ? V2 : V1)

#define MX25L4_MEM_START	0x00			//!< Punto di inizio della memoria
//***********************************************************
//++++++++++++ Definizione Variabili Private ++++++++++++++++
//***********************************************************

typedef struct
{
	uint8_t packetSize; 		//!< Dimensione del pacchetto
	uint8_t firmwareVersion; 	//!< Versione del firmware
	uint32_t addrFreeSpace; 	//!< Ultimo indirizzo scritto
} MX25L4_TypeDef;

MX25L4_TypeDef memoryContext;

//***********************************************************
//++++++++++++ Definizione delle Funzioni +++++++++++++++++++
//***********************************************************

/**
 * Attivazione del Chip Select
 */
void CS_Select();

/**
 * Deselezione del Chip Select
 */
void CS_Unselect();

/**
 * Trasmissione con SPI
 */
bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Ricezione con SPI
 */
bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Invio di un comando singolo con SPI, attiva e disattiva in automatico il chip select
 */
bool MEM_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout);

/**
 * Inizzializza il contesto
 *
 * @param pData		Array con i 4 Byte dell'header
 */
bool MEM_UpdateContext(uint8_t *pData);

/**
 * Ricerca del primo blocco libero, modifica il contesto
 * @param start_address		Indirizzo di partenza per effettuare la ricerca
 *
 * @return	False se all'indirizzo start_address non è stato trovato l'header, altrimenti true.
 */
bool MEM_FindFreeSpace(uint32_t start_address);

/**
 * Verifica se è un Header valido della memoria
 *
 * @param pData		puntatore all'array di lunghezza "MX25L4_HEADER_BYTE_NUM"
 */
bool MEM_IsHeader(uint8_t *pData);

/**
 * Scrittura dell'header sulla memoria
 *
 * @param addr		Indirizzo dove scrivere l'header
 */
bool MEM_WriteHeader(uint32_t addr);

/**
 * Scrittura sulla memoria all'indirizzo specificato, NON aggiorna l'indirizzo della memoria libera (contesto)
 *
 * @param pData 	Dati da scrivere in memoria
 * @param size 		numero di byte da scrivere
 * @param addr		indirizzo su cui scrivere la memoria
 *
 */
bool MEM_Write(uint8_t *pData, uint16_t size, uint32_t addr);

/**
 * Veridica se l'area di memoria è tutta libera
 *
 * @param pData		L'array da verificare
 * @param size		dimensione dell'array
 *
 * @return			True, se tutti i valori di pData sono a 0xFF altrimenti false.
 */
bool MEM_IsFree(uint8_t *pData, uint8_t size);

/**
 * Lettura dei registri della memoria
 *
 *  @param registerStatus	[out] valori dei registri lettiFss
 */
bool MEM_ReadRegister(uint8_t *pData);

//***********************************************************
//++++++++++++++++ Funzioni Public ++++++++++++++++++++++++++
//***********************************************************

bool MX25L4_Init(void)
{
	bool isOK = true;

	// Inizzializzazione del contesto
	memoryContext.packetSize = 0;
	memoryContext.firmwareVersion = 0;
	memoryContext.addrFreeSpace = 0;

	// Inizializzazione - CS e HOLD
	CS_Unselect();
	HAL_GPIO_WritePin(MX25L4_HOLD_Port, MX25L4_HOLD_Pin, GPIO_PIN_SET);

	// Inizializzazione - SPI [GIÀ FATTO NEL MAIN.. DEVO FARLO?]
	//isOK &= HAL_SPI_Init(&MX25L4_hspi) == HAL_OK;

	// Verifica del funzionamento del dispositivo
	isOK &= MX25L4_ReadID() == MX25L4_ID;

	// inizializzazione del contesto della memoria
	if (!MEM_FindFreeSpace(MX25L4_MEM_START)) // se vero -> header non trovato!
	{
		MEM_WriteHeader(memoryContext.addrFreeSpace); // scrittura dell'header
	}

	return isOK;
}

uint32_t MX25L4_ReadID()
{
	uint8_t pID[3];
	uint32_t id = 0;
	uint8_t cmd = MX25L4_CMD_RDID;
	bool isOK = true;

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pID, 3, MX25L4_MAX_CMD_TIME);

	// Chip Select - OFF
	CS_Unselect();

	id = pID[0] << 16 | pID[1] << 8 | pID[2];

	if (!isOK)
	{
		id = 0;
	}
	return id;
}

bool MX25L4_ReadData(uint8_t *pData, uint16_t size, uint32_t address)
{
	uint8_t isOK = true;
	uint8_t cmd[4] =
	{ MX25L4_CMD_READ, MX25L4_BYTE2(address), MX25L4_BYTE1(address), MX25L4_BYTE0(address) };

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(cmd, 4, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pData, size, MX25L4_MAX_RW_TIME);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;
}

bool MX25L4_Sleep()
{
	uint8_t cmd = MX25L4_CMD_DP;

	return MEM_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_Wakeup()
{
	uint8_t cmd = MX25L4_CMD_RDP;

	return MEM_SendCMD(&cmd, 1, MX25L4_MAX_CMD_TIME);
}

bool MX25L4_isOccupied()
{
	uint8_t registerStatus;
	MEM_ReadRegister(&registerStatus);
	return (registerStatus & 0x01) == 0x01; // Lettura dell'ultimo bit e verifica se è pari a 1 (Occupato)
}

bool MX25L4_WriteData(uint8_t *pData, uint16_t size, uint32_t *address)
{
	bool isOK = true;

	if (size > MX25L4_PACKET_SIZE)
	{
		return false;
	}
	if (address != NULL)
	{
		*address = memoryContext.addrFreeSpace;
	}
	isOK &= MEM_Write(pData, size, memoryContext.addrFreeSpace);

	memoryContext.addrFreeSpace += MX25L4_PACKET_SIZE;

	return isOK;
}

//***********************************************************
//++++++++++++++++ Funzioni Private ++++++++++++++++++++++++++
//***********************************************************

inline void CS_Select()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_RESET);
}

inline void CS_Unselect()
{
	HAL_GPIO_WritePin(MX25L4_CS_Port, MX25L4_CS_Pin, GPIO_PIN_SET);
}

inline bool SPI_Transmit(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Transmit(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

inline bool SPI_Receive(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	return HAL_SPI_Receive(&MX25L4_SPI, pData, Size, Timeout) == HAL_OK;
}

bool MEM_SendCMD(uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
	bool isOK = true;

	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(pData, Size, Timeout);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;

}

bool MEM_UpdateContext(uint8_t *pData)
{
	memoryContext.firmwareVersion = pData[2];
	memoryContext.packetSize = pData[3];
	return true;
}

bool MEM_FindFreeSpace(uint32_t start_address)
{
	bool isOK = true;
	bool stop = false;
	uint8_t pData[MX25L4_FORWARD_CHECK];
	uint32_t addr = start_address;

	// Ciclo di scan della memoria
	while (!stop)
	{
		MX25L4_ReadData(pData, MX25L4_FORWARD_CHECK, addr); // lettura della memoria

		if (MEM_IsHeader(pData)) // Se troviamo un header aggiorniamo il contesto
		{
			MEM_UpdateContext(pData); 		// aggiorniamo il contesto
			addr += MX25L4_HEADER_BYTE_NUM; // spostiamo l'indirizzo
		}
		else if (MEM_IsFree(pData, MX25L4_FORWARD_CHECK)) // se è memoria libera ci fermiamo.
		{
			// verifichiamo se la versione del firmware trovata è uguale a quella dichiarata
			isOK &= memoryContext.firmwareVersion != MX25L4_FIRMWARE_VERSION;
			stop = true;
		}
		else // Memoria occupata
		{
			addr += memoryContext.packetSize; // avanzioamo di un pacchetto
		}
	}

	memoryContext.addrFreeSpace = addr;

	return true;
}

bool MEM_WriteHeader(uint32_t addr)
{
	bool isOK = true;
	uint8_t pData[MX25L4_HEADER_BYTE_NUM] =
	{ MX25L4_HEADER_BYTE_0, MX25L4_HEADER_BYTE_1, MX25L4_FIRMWARE_VERSION, MX25L4_PACKET_SIZE };

	isOK &= MEM_Write(pData, MX25L4_HEADER_BYTE_NUM, addr);
	return isOK;
}

bool MEM_IsHeader(uint8_t *pData)
{
	bool isOK = true;
	isOK &= pData[0] == MX25L4_HEADER_BYTE_0;
	isOK &= pData[1] == MX25L4_HEADER_BYTE_1;
//	isOK &= (pData[2] == (memoryContext.firmwareVersion + 1)); 	// Versioni del firmware consecutive TODO da chiedere
//	isOK &= ((pData[3] % 2) == 0); 								// Dimensioni del pacchetto "pari" TODO da chiedere
	return isOK;
}

bool MEM_IsFree(uint8_t *pData, uint8_t size)
{
	for (uint8_t i = 0; i < size; i++)
	{
		if ((pData[i] & 0xFF) != 0xFF)
		{
			return false;
		}
	}
	return true;
}

bool MEM_Write(uint8_t *pData, uint16_t size, uint32_t addr)
{
	bool isOK = true;

	uint8_t cmdWREN = MX25L4_CMD_WREN;
	uint8_t payLoad = 1 + 3; // payLoad per inviare il comando: CMD + ADD1 + ADD2 + ADD3
	// Creo un'area di memoria continua (comando + indirizzo + dati) in modo tale da
	uint8_t *cmdWRITE = malloc((size_t) (payLoad + MX25L4_MIN(size, MX25L4_MEM_PAGE))); // TODO da chiedere se va bene

	// verifica se si è riusciti ad allocare la memoria
	if (cmdWRITE == NULL)
	{
		return false;
	}

	uint16_t byteLiberi = 0;	// Numero di byte liberi per la pagina attuale
	uint16_t daScrivere = 0; 	// dati da scrivere attraverso uno comando
	bool stop = false; 			// Indica se si deve concludere il ciclo while

	cmdWRITE[0] = MX25L4_CMD_PP;

	while (!stop)
	{

		byteLiberi = MX25L4_MEM_PAGE - MX25L4_BYTE0(addr);
		// Scrivo solo i dati che ci stanno nella pagina oppure quelli che devo scrivere
		daScrivere = MX25L4_MIN(byteLiberi, size);

		// scrittura degli indirizzi nel comando
		cmdWRITE[1] = MX25L4_BYTE2(addr);
		cmdWRITE[2] = MX25L4_BYTE1(addr);
		cmdWRITE[3] = MX25L4_BYTE0(addr);

		// copia dei dati in memoria (dopo il payload)
		memcpy(cmdWRITE + payLoad, pData, daScrivere);

		// Abilitazione della scrittura
		MEM_SendCMD(&cmdWREN, 1, MX25L4_MAX_CMD_TIME);

		// Esecuzione scrittura
		MEM_SendCMD(cmdWRITE, daScrivere + payLoad, MX25L4_MAX_RW_TIME);

		// Operazioni finali
		pData += daScrivere; 	// Sposto il puntatore dei dati su quelli non ancora letti
		addr += daScrivere;		// Sposto l'indirizzo di memoria su cui scrivere
		size -= daScrivere;		// Riduco il numero di dati da scrivere
		if (size == 0) 			// se abbiamo finito di scrivere mi fermo
		{
			stop = true;
		}
	}

	return isOK;
}

bool MEM_ReadRegister(uint8_t *pData)
{
	bool isOK = true;
	uint8_t cmd = MX25L4_CMD_RDSR;
	// Chip Select - ON
	CS_Select();

	isOK &= SPI_Transmit(&cmd, 1, MX25L4_MAX_CMD_TIME);
	isOK &= SPI_Receive(pData, 1, MX25L4_MAX_RW_TIME);

	// Chip Select - OFF
	CS_Unselect();

	return isOK;
}
